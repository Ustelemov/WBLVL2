package pattern

import "fmt"

/*
	Реализовать паттерн «комманда».
	Объяснить применимость паттерна, его плюсы и минусы,
	а также реальные примеры использования данного паттерна на практике.
	https://en.wikipedia.org/wiki/Command_pattern

	Паттерн превращает запросы в отдельные объекты,
	отделяя запросы от класса отправителя, позволяя осуществлять работу
	с запросами в рантайме, реализуя различные операции: выстраивание очередей
	команд, хранение истории, реализации отмены и другое.

	Например, может использоваться для разделения слоя графического интерфейса,
	от слоя бизнес-логики, которые будут общаться друг с другом посредством
	объектов команд: отправитель (графический интерфейс) будет вызывать нужную команду,
	а получатель (бизнес-логика) будет делать нужное действие.
	При этом детали будут скрытых от обоих узлов.

	Плюсы:
	- Убирается прямая связь между отправителями и исполнителями запросов
	- Позволяет удобно реализовывать различные операции: отмена и повтор запросов,
	отложенный запуск запросов, выстраивание очереди запросов.

	Минусы:
	- Усложняет код из-за необходимости реализации дополнительных классов

	Реализовать паттерн можно для создания взаимодействия между
	кнопкой на пульте (интерфейсом, отправителем) и телевизором (бизнес-логикой, приемником).
	Команды On и Off будут включать и выключать телевизор.
*/

//Создаем базовый интерфейс команды, требующие реализации единственного
//метода - выполнения
type Command interface {
	Execute()
}

//Конкретная реализация команды включения, содержит поле - приемник
type OnCommand struct {
	device Device
}

//Метод выполнение для команды - вызываем соответствующий метод у приемника
func (on *OnCommand) Execute() {
	on.device.On()
}

//Конкретная реализация команды выключения, содержит поле - приемник
type OffCommand struct {
	device Device
}

//Метод выполнение для команды - вызываем соответствующий метод у приемника
func (off *OffCommand) Execute() {
	off.device.Off()
}

//Объект кнопка - отправитель команды, содержит поле - команда
type Button struct {
	command Command
}

//Нажатие кнопки исполняет сохраненную команду
func (b *Button) Press() {
	b.command.Execute()
}

//Интерфейс устройства, требующий реализации методов включения и выключения
type Device interface {
	On()
	Off()
}

//Конкретная реализация устройства с полем - флагом состояния:
//показывает - включен, не показывает - выключен
type TV struct {
	isShowing bool
}

//Метод включения устройства
func (tv *TV) On() {
	tv.isShowing = true
	fmt.Println("Showing")
}

//Метод выключения устройства
func (tv *TV) Off() {
	tv.isShowing = false
	fmt.Println("No Showing")
}

func main() {
	tv := &TV{} //создаем устройство - получатель команды

	onButton := Button{
		command: &OnCommand{device: tv},
	} //создаем кнопку - отправитель команды сразу с заданием нужной команды

	offButton := Button{
		command: &OffCommand{device: tv},
	} //создаем другую кнопку - отправитель с другой командой

	//нажимаем обе созданные кнопки - включаем, а затем выключаем
	onButton.Press()
	offButton.Press()
}
