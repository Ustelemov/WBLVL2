package pattern

import "fmt"

/*
	Реализовать паттерн «фабричный метод».
	Объяснить применимость паттерна, его плюсы и минусы,
	а также реальные примеры использования данного паттерна на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern

	Паттерн опредляет общий интерфейс создания объектов в суперклассе,
	позволяя классам потомкам переопределять создание, изменяя тип
	создаваемых объектов.
	Так мы создаем объекты не напрямую, а через фабричные методы, отделяя
	создание объектов от их использования. Остальной код будет работать
	с базовым интерфейсом, а мы сможем расширять количество объектов без
	изменения основного кода (мы не привязываемся к конкретным классам объектов).

	Плюсы:
	- Избавляет от привязки к использованию конкретного объекта,
	набор используемых объектов можно расширить, не изменяя остального кода.
	- Выделяет производство объектов в одно место, упрощяя навигацию
	по коду и его поддержку.

	Минусы:
	- Требуется реализация дополнительных объектов создания, что усложняет
	код
	- Может привести к созданию больших параллельных иерархий объектов,
	так как для создания каждого типа объекта нужен свой создатель.

	В Go реализовать классический вариант фабричного метода невозможно
	из-за отсутствия ООП в общем понимании: не создать базовый класс
	с абстрактным методом создания, который будет переопределяться в потомках.
	Но можно реализовать паттерн простая фабрика - класс с условным
	оператором, выбирающий какой объект требуется создать.

	В качестве примера реализации можно реализовать создание разных
	типов фруктов с помощью фабрики.
*/

//Определим базовый интерфейс, требующий все методы будущих фруктов
type IFruct interface {
	Name() string
	SetName(string)
	Size() int
	SetSize(int)
}

//Реализуем интерфейс, создав базовый объект фрукт
type Fruct struct {
	name string
	size int
}

//Получаем имя фрукта
func (f *Fruct) Name() string {
	return f.name
}

//Устанавливаем имя фрукта
func (f *Fruct) SetName(n string) {
	f.name = n
}

//Получаем размер фрукта
func (f *Fruct) Size() int {
	return f.size
}

//Устанавливаем размер фрукта
func (f *Fruct) SetSize(s int) {
	f.size = s
}

//Реализуем наследника базового фрукта - конкретный фрукт Киви
type Kiwi struct {
	Fruct
}

//Создание нового объекта Kiwi
func NewKiwi() IFruct {
	return &Kiwi{
		Fruct: Fruct{
			name: "Kiwi",
			size: 1,
		},
	}
}

//Реализуем ещё одного наследника базового фрукта - Apple
type Apple struct {
	Fruct
}

//Создание нового объекта Apple
func NewApple() IFruct {
	return &Apple{
		Fruct: Fruct{
			name: "Apple",
			size: 2,
		},
	}
}

//Реализуем простую фабрику
func getFruct(fructType string) (IFruct, error) {
	switch fructType {
	case "Kiwi":
		return NewKiwi(), nil
	case "Apple":
		return NewApple(), nil
	default:
		return nil, fmt.Errorf("No fructType: %s found", fructType)
	}
}

//Функция, печатающая информацию о фрукте, принимает интерфейс IFruct
//Видим, что с такой реализацией фабрики, мы не зависим от конкретного объекта (фрукта)
func printFruct(fruct IFruct) {
	fmt.Printf("Fruct name: %s\n", fruct.Name())
	fmt.Printf("Fruct size: %d\n", fruct.Size())
}

func main() {
	kiwi, _ := getFruct("Kiwi")
	apple, _ := getFruct("Apple")

	printFruct(kiwi)
	printFruct(apple)
}
