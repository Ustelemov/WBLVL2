package pattern

import "fmt"

/*
	Реализовать паттерн «строитель».
	Объяснить применимость паттерна, его плюсы и минусы,
	а также реальные примеры использования данного паттерна
	на практике.
	https://en.wikipedia.org/wiki/Builder_pattern

	Паттерн используется, когда у нас есть неизменяемый сложносоставной объект, различные
	предствления которого могут включать разные его части.
	Вместо "телескопического конструктора" - множественных перегруженных конструкторов
	(а в Го ещё и нет перегрузки, придется создавать с разными именами)
	мы можем реализовать объект строитель,
	пошагово создающий объект с теми частями, которые нам будут нужны.

	Если потребуется объединить шаги создания создается объект директор, определяющий
	порядок шагов, так процесс создания будет полностью скрыт от клиента
	(директор - не является обязательным в реализации паттерна)

	Плюсы:
	- Анти-паттерн для паттерна "Телескопический конструктор":
		- Большая читабельность и меньшая вероятность ошибки
		- Облегчается поддержка: нет большого числа конструкторов с разным количеством параметров
		- В Го так как нет перегрузок значительно упрощает разработку и использование
	- Создает объекты пошагово (если это требуется, например, деревья)
	- Позволяет создавать несколько представлений одного объекта, переиспользуя код

	Минусы:
	- Объект билдер должен быть изменяемый
	- Усложняет код, требуется написание дополнительных классов, может усложняться внедрнее зависимостей

	Примером может послужить реализация объекта пицца, в которую могут добавляться или не добавляться ингредиенты.
*/

//Cложносостовной объект пицца, который разные представление которого
//могут включать разные элементы (нужные поля - True)
type Pizza struct {
	//полей может быть ещё больше, для примера возьмем некоторые
	isChesse  bool
	isMeat    bool
	isOlivies bool
	isPepper  bool
}

//Общий конструктор для всех элементов
func NewPizza(ch bool, mt bool, ol bool, pep bool) *Pizza {
	return &Pizza{isChesse: ch, isMeat: mt, isOlivies: ol, isPepper: pep}
}

//Каждый Builder пиццы должны реализовывать этот интерфейс
//(даже если возвращаемые результаты сборки потом будут разных классов -
// у нас может потом быть не пицца, а например бумажное описание пиццы PapperPizza)
type Builder interface {
	setChesse()
	setMeat()
	setOlivies()
	setPepper()
}

//Реализуем Builder с набором полей как у исходного объекта
type PizzaBuilder struct {
	isChesse  bool
	isMeat    bool
	isOlivies bool
	isPepper  bool
}

//Конструктор без параметром, создающий дефолтный объект билдера
func NewPizzaBuilder() *PizzaBuilder {
	return &PizzaBuilder{}
}

//Сеттеры для каждого поля
func (p *PizzaBuilder) setChesse() *PizzaBuilder {
	p.isChesse = true
	return p
}

func (p *PizzaBuilder) setMeat() *PizzaBuilder {
	p.isMeat = true
	return p
}

func (p *PizzaBuilder) setOlivies() *PizzaBuilder {
	p.isOlivies = true
	return p
}

func (p *PizzaBuilder) setPepper() *PizzaBuilder {
	p.isPepper = true
	return p
}

//Метод создания итогового объекта - итоговый результат построения
//вызывается общий конструктор Пиццы
func (p *PizzaBuilder) build() *Pizza {
	return NewPizza(p.isChesse, p.isMeat, p.isOlivies, p.isPepper)
}

func main() {
	pizza := NewPizzaBuilder(). //создаем объект билдер
					setChesse(). //добавляем нужные части объекта (нужные - становятся True)
					setPepper().
					build() //создаем возращаем объект Pizza
	fmt.Println(pizza)
}
