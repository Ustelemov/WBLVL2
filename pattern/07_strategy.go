package pattern

import "fmt"

/*
	Реализовать паттерн «стратегия».
	Объяснить применимость паттерна, его плюсы и минусы,
	а также реальные примеры использования данного паттерна на практике.
	https://en.wikipedia.org/wiki/Strategy_pattern

	Паттерн определяет семейство алгоритмов при помощи интерфейса и
	помещает каждую реализацию в свой класс, который будет реализовывать
	базовый интерфейс семейства. Такой подход позволит взаимозаменять
	алгоритмы в рантайме.

	Плюсы:
	- Возможность замены алгоритмов в рантайме
	- Отделение алгоритмов от остальной логики, сокрытие самих алгоритмов
	Минусы:
	- Усложнение кода, засчет введения дополнительных объектов
	- Клиент должен знать в чем состоит отличие алгоритмов, чтобы выбрать нужный

	Для примера реалзиации паттерна рассмотрим разработку In-Memory Cache.
	Так как кеш находится внутри памяти - размер его ограничен.
	Когда память заполнится (либо чуть раньше) потребуется удалить
	какие-то записи. Сделать это можно несколькими способами - алгоритмами:
	- Least Recently Used (LRU) - убрать запись, использовавшуюсь наиболее
	давно
	- FIFO - убрать запись, созданную раньше остальных
	- Least Frequently Used (LFU) - убрать запись наименее часто
	использовавшуюся

	При этом требуется отделить алгоритмы от кеша, для возможности
	замены алгоритма в рантайме и для возможности их модификации без
	изменения кода кеша.
*/

//Базовый интерфейс, определяющий алгоритмы очистки кэша
//одним соответствующим методом очистки
type EvictionAlgos interface {
	Evict(c *Cache)
}

//Создадим объект кеш, содержащий в себе поля: len - текущее кол-во
//элементов, maxLen - емкость (возможное количество элементов)
//и объект типа интерфейса алгоритма очистки
type Cache struct {
	len      int
	maxLen   int
	evictAlg EvictionAlgos
}

//Метод добавления элемента - если будет вместимость будет переполнена,
//то освободим место при помощи алгоритма очистки до добавления
func (c *Cache) Add(v int) {
	if c.len == c.maxLen {
		c.Evict()
	}
	c.len = c.len + 1
}

//Метод установки алгоритма очистки
func (c *Cache) SetEvictAlg(ev EvictionAlgos) {
	c.evictAlg = ev
}

//Реализуем метод очистки для кеша, он будет вызывать соответствующий алгоритм
//и для простоты сам уменьшать счетчик количества элементов
func (c *Cache) Evict() {
	c.evictAlg.Evict(c)
	c.len = c.len - 1

}

//Реализуем разные алгоритмы очистки, все они реализуют метод Evict,
//а значит реализуют и базовый интерфейс алгоритма
type FIFO struct{}

func (f *FIFO) Evict(c *Cache) {
	fmt.Println("Evicted with FIFO")
}

type LRU struct{}

func (l *LRU) Evict(c *Cache) {
	fmt.Println("Evicted with LRU")
}

type LFU struct{}

func (l *LFU) Evict(c *Cache) {
	fmt.Println("Evicted with LFU")
}

func main() {
	c := Cache{
		len:      0,
		maxLen:   2,
		evictAlg: nil,
	}

	fifo := FIFO{}
	c.SetEvictAlg(&fifo)

	c.Add(1)
	c.Add(1)
	c.Add(1) //количество элементов привысит допустимое количество
	//перед добавлением будет вызван алгоритм очистки

	lru := LRU{}
	c.SetEvictAlg(&lru) //изменим алгоритм "на лету"
	c.Add(1)
}
